//! lyra (randomly named)

use crate::isle::Isle;
use crate::locked::Locked;
use serde::{Deserialize, Serialize};
use sha2::digest::{Digest, FixedOutput};
use sha2::Sha256;

/// Lyra provides:
/// |                      |     |
/// | -                    | -   |
/// | Encryption           | yes |
/// | Authentication       | yes |
/// | DOS Resistance       | no  |
/// | Half Forward Secrecy | yes |
/// | Forward Secrecy      | yes |
/// | Stateless Datagrams  | no  |
/// | Ordering             | no  |
/// | Reliability          | no  |
/// | Multiplexing         | yes |
#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub enum Lyra<T> {
    /// Sent from the initiator to create a session
    InitiateOpen(Isle<InitiateOpenChannel>), // TODO, include the outer pub key in payload
    /// Sent as a reply to InitiateOpen
    FinalizeOpen(Isle<FinalizeOpenChannel>),
    /// Data sent to a supposedly already open channel
    ChannelData(ChannelData<T>),
}

#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub struct InitiateOpenChannel {
    pub initiator_random: [u8; 32], // Random number generated by the initiator
}

#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub struct FinalizeOpenChannel {
    pub initiator_random_hash: [u8; 32], // sha256 hash of the random number sent by the initiator
    pub responder_random: [u8; 32],      // Random number generated by the responder
}

#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub struct ChannelData<T> {
    /// The key is secret, but the salted sha256 hash of the key is not.
    salted_hash_of_secret: [u8; 32],
    locked_data: Locked<T>,
}

fn salted_hash(secret: &[u8; 32]) -> [u8; 32] {
    const SALT: &str = "f60fc7125eeb7ef5507c2a0d872be8d446c9bd8ebe41037a4001b3bf79de6a35";
    let a = Sha256::new().chain(SALT).chain(&secret).fixed_result();
    let mut b: [u8; 32] = [0; 32];
    b.copy_from_slice(a.as_slice());
    b
}
