//! lyra (randomly named)

use crate::locked::Locked;
use sealed::Sealed;
use serde::{Deserialize, Serialize};
use sha2::digest::{Digest, FixedOutput};
use sha2::Sha256;

/// Lyra provides:
/// |                     |     |
/// | -                   | -   |
/// | Encryption          | yes |
/// | Authentication      | yes |
/// | DOS Resistance      | no  |
/// | Forward Secrecy     | yes |
/// | Stateless Datagrams | no  |
/// | Ordering            | no  |
/// | Reliability         | no  |
/// | Multiplexing        | yes |
#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub enum Lyra<T> {
    /// Sent from the initiator to create a session
    InitiateOpen(Sealed<Sealed<InitiateOpenChannel>>),
    /// Sent as a reply to InitiateOpen
    FinalizeOpen(Sealed<Sealed<FinalizeOpenChannel>>),
    /// Data sent to a supposedly already open channel
    ChannelData(Locked<ChannelData<T>>),
}

#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub struct InitiateOpenChannel {
    initiator_random: [u8; 32], // Random number generated by the initiator
}

#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub struct FinalizeOpenChannel {
    initiator_random_hash: [u8; 32], // sha256 hash of the random number sent by the initiator
    responder_random: [u8; 32],      // Random number generated by the responder
}

#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub struct ChannelData<T> {
    /// The key is secret, but the salted sha256 hash of the key is not.
    salted_hash_of_secret: [u8; 32],
    locked_data: Locked<T>,
}

fn salted_hash(secret: &[u8; 32]) -> [u8; 32] {
    const SALT: &str = "f60fc7125eeb7ef5507c2a0d872be8d446c9bd8ebe41037a4001b3bf79de6a35";
    let a = Sha256::new().chain(SALT).chain(&secret).fixed_result();
    let mut b: [u8; 32] = [0; 32];
    b.copy_from_slice(a.as_slice());
    b
}
