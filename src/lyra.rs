//! lyra (randomly named)

use crate::common::xor;
use crate::isle::Isle;
use crate::locked::Locked;
use crate::lyra_channel::ChannelId;
use crate::sha_ext::Sha256Ext;
use core::ops::BitXor;
use rust_sodium::crypto::secretbox::Key;
use serde::{Deserialize, Serialize};
use sha2::{digest::Digest, Sha256};

/// Lyra provides:
/// |                      |         |
/// | -                    | -       |
/// | Encryption           | yes     |
/// | Authentication       | yes     |
/// | DOS Resistance       | no      |
/// | Forward Secrecy      | yes     |
/// | Stateless Datagrams  | no      |
/// | Ordering             | no      |
/// | Reliability          | no      |
/// | Multiplexing         | yes     |
/// | Replay Protection    | partial |
#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub enum Lyra<T> {
    /// Sent from the initiator to create a session
    InitiateOpen(Isle<RequestChannel>),
    /// Sent as a reply to InitiateOpen
    FinalizeOpen(Isle<GrantChannel>),
    /// Data sent to a supposedly already open channel
    ChannelData(ChannelData<T>),
}

#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub struct RequestChannel {
    pub initiator_random: EphemeralSecret256, // Random number generated by the initiator
}

#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub struct GrantChannel {
    pub initiator_random_hash: EphemeralSecret256Hash, // sha256 hash of the random number sent by the initiator
    pub responder_random: EphemeralSecret256,          // Random number generated by the responder
}

#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
pub struct ChannelData<T> {
    pub channel_id: ChannelId,
    pub locked_data: Locked<T>,
}

#[derive(Serialize, Deserialize, PartialEq, Eq, Hash, Clone, Debug)]
/// The hash of an ephemeral secret is considered public.
pub struct EphemeralSecret256 {
    random_secret: [u8; 32],
}

#[derive(Serialize, Deserialize, PartialEq, Eq, Hash, Clone, Debug)]
/// Identifier of epehmeral secret. The hash of an ephemeral secret is considered public.
pub struct EphemeralSecret256Hash {
    pub hashed_random_secret: [u8; 32],
}

impl EphemeralSecret256 {
    pub fn random() -> EphemeralSecret256 {
        EphemeralSecret256 {
            random_secret: rand::random(),
        }
    }

    /// The hash of an ephemeral secret is considered public.
    pub fn id(&self) -> EphemeralSecret256Hash {
        const SALT: &str = "3844437d53db02f90f435a1d7e5270878fc9e699c04b09f386de2e97ffcbc982";
        EphemeralSecret256Hash {
            hashed_random_secret: Sha256::new()
                .chain(SALT)
                .chain(&self.random_secret)
                .result_array(),
        }
    }
}

impl BitXor for &EphemeralSecret256 {
    type Output = Key;
    fn bitxor(self, other: &EphemeralSecret256) -> Self::Output {
        Key(xor(&self.random_secret, &other.random_secret))
    }
}
